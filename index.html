<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>VRM Animation Player (CDN version)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 8px 12px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 14px;
    }
    #ui input { margin-top: 4px; }
    #canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
  <!-- UI -->
  <div id="ui">
    <div>
      VRM ファイル: <input id="vrmInput" type="file" accept="*.vrm" />
    </div>
    <div>
      モーション (.vrma 任意): <input id="animInput" type="file" accept="*.vrma" />
    </div>
    <p style="margin:4px 0 0;font-size:12px;line-height:1.2;">
      ※ モーションを選択しない場合は <code>./idle.vrma</code> を自動ロードします。<br />
      ファイルの大きさに応じて読み込みに時間がかかる場合があります。
    </p>
  </div>
  <canvas id="canvas"></canvas>

  <!-- Three.js & VRM ライブラリを CDN から読み込み -->
  <script type="module">
    // Three.js
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/loaders/GLTFLoader.js';

    // VRM 本体
    import {
      VRMLoaderPlugin,
      MToonMaterialLoaderPlugin,
    } from 'https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.1/lib/three-vrm.module.js';

    // VRM Animation (.vrma)
    import {
      VRMAnimationLoaderPlugin,
      createVRMAnimationClip,
    } from 'https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@2.1.0/lib/three-vrm-animation.module.js';

    // -------- グローバル変数 --------
    let scene, camera, renderer, clock, mixer;
    let currentVRM;

    // -------- 初期化 --------
    init();

    // UI 要素
    const vrmInput = document.getElementById('vrmInput');
    const animInput = document.getElementById('animInput');

    vrmInput.addEventListener('change', handleVRM, false);
    animInput.addEventListener('change', handleAnimation, false);

    // VRM 読み込み
    async function handleVRM(e) {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      await loadVRM(url);
      URL.revokeObjectURL(url);

      // モーションが選択されていなければ idle.vrma を適用
      if (!animInput.files.length) {
        await loadAnimation('./idle.vrma');
      }
    }

    // VRMA 読み込み
    async function handleAnimation(e) {
      const file = e.target.files[0];
      if (!file || !currentVRM) return;
      const url = URL.createObjectURL(file);
      await loadAnimation(url);
      URL.revokeObjectURL(url);
    }

    // VRM を読み込んでシーンへ追加
    async function loadVRM(url) {
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));
      loader.register((parser) => new MToonMaterialLoaderPlugin(parser));

      if (currentVRM) {
        scene.remove(currentVRM.scene);
        currentVRM = null;
      }

      try {
        const gltf = await loader.loadAsync(url);
        currentVRM = gltf.userData.vrm;
        scene.add(currentVRM.scene);
      } catch (err) {
        console.error('[VRM Load Error]', err);
      }
    }

    // VRMA を読み込んで再生
    async function loadAnimation(url) {
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

      try {
        const gltf = await loader.loadAsync(url);
        const vrma = gltf.userData.vrmAnimation;
        const clip = createVRMAnimationClip(vrma, currentVRM);

        if (!mixer) mixer = new THREE.AnimationMixer(currentVRM.scene);
        mixer.stopAllAction();
        mixer.clipAction(clip).play();
      } catch (err) {
        console.error('[Animation Load Error]', err);
      }
    }

    // Three.js 初期化
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(0, 1.4, 3);

      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('canvas'),
        antialias: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.2, 0);
      controls.update();

      // ライト
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
      hemiLight.position.set(0, 1, 0);
      scene.add(hemiLight);

      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(0, 3, 3);
      scene.add(directional);

      const grid = new THREE.GridHelper(10, 10);
      scene.add(grid);

      clock = new THREE.Clock();

      window.addEventListener('resize', onWindowResize, false);
      animate();
    }

    // リサイズ対応
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // 描画ループ
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
