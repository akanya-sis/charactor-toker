<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>VRM Animation Player (CDN version)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 8px 12px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 14px;
    }
    #ui input { display: block; margin-bottom: 6px; }
    #log { margin-top: 4px; font-size: 12px; color: #333; max-width: 320px; white-space: pre-wrap; }
  </style>

  <!-- Import map to resolve bare specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.178.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.178.0/examples/jsm/",
      "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.4.1/lib/three-vrm.module.js",
      "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@2.1.0/lib/three-vrm-animation.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="ui">
    <label>VRM ファイル: <input type="file" id="vrmInput" accept=".vrm"></label>
    <label>モーション (.vrma): <input type="file" id="animInput" accept=".vrma"></label>
    <div id="log"></div>
  </div>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRMUtils, VRMLoaderPlugin } from '@pixiv/three-vrm';
    import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.4, 2.4);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.2, 0);
    controls.enableDamping = true;

    // light
    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(1, 3, 2);
    scene.add(light);

    const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
    scene.add(grid);

    // mixers
    let mixer = null;
    let currentVRM = null;

    function unloadCurrentVRM() {
      if (currentVRM) {
        currentVRM.scene.traverse((obj) => {
          if (obj.isMesh) {
            obj.geometry?.dispose();
            if (obj.material.map) obj.material.map.dispose();
            obj.material?.dispose();
          }
        });
        scene.remove(currentVRM.scene);
        VRMUtils.deepDispose(currentVRM.scene);
        currentVRM = null;
      }
      if (mixer) {
        mixer.stopAllAction();
        mixer = null;
      }
    }

    async function loadVRM(file) {
      unloadCurrentVRM();

      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));

      const arrayBuffer = await file.arrayBuffer();
      const gltf = await loader.parseAsync(arrayBuffer, '');
      const vrm = gltf.userData.vrm;
      currentVRM = vrm;
      scene.add(vrm.scene);

      log('Loaded VRM: ' + (vrm.meta?.title || file.name));

      // fit view
      const hips = vrm.humanoid?.getNormalizedBoneNode('hips') || vrm.humanoid?.getRawBoneNode('hips');
      if (hips) {
        controls.target.copy(hips.getWorldPosition(new THREE.Vector3()));
      } else {
        controls.target.set(0, 1.2, 0);
      }
      controls.update();
    }

    async function loadAndPlayVRMA(file) {
      if (!currentVRM) {
        log('VRM を先に読み込んでください');
        return;
      }
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMAnimationLoaderPlugin(parser));
      const arrayBuffer = await file.arrayBuffer();
      const gltf = await loader.parseAsync(arrayBuffer, '');

      const vrma = gltf.userData.vrmAnimation || gltf.userData.vrmAnimations?.[0];
      if (!vrma) {
        log('VRMA が見つかりません');
        return;
      }

      // -- 変更点ここ：Binder オブジェクトで VRM を渡す --
      const clip = createVRMAnimationClip(vrma, { vrm: currentVRM });

      if (!mixer) {
        mixer = new THREE.AnimationMixer(currentVRM.scene);
      } else {
        mixer.stopAllAction();
      }
      mixer.clipAction(clip).reset().play();
      log('Played animation: ' + (vrma.meta?.title || file.name));
    }

    // default idle.vrma fetch (optional)
    async function tryPlayDefaultIdle() {
      try {
        const resp = await fetch('./idle.vrma');
        if (!resp.ok) throw new Error('idle.vrma not found');
        const buffer = await resp.arrayBuffer();
        await loadAndPlayVRMA(new File([buffer], 'idle.vrma'));
      } catch (e) {
        log('idle.vrma を読み込めませんでした（任意）');
      }
    }

    // UI events
    document.getElementById('vrmInput').addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (file) loadVRM(file).then(() => tryPlayDefaultIdle());
    });
    document.getElementById('animInput').addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (file) loadAndPlayVRMA(file);
    });

    // render loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // log helper
    function log(msg) {
      const div = document.getElementById('log');
      div.textContent = msg;
      console.log(msg);
    }

    // resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
