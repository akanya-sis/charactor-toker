<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>VRM Animation Player (CDN version)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.85);
      padding: 8px 12px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 14px;
    }
    #ui input { display: block; margin-bottom: 6px; }
    #log { margin-top: 4px; font-size: 12px; color: #333; max-width: 320px; white-space: pre-wrap; }
  </style>

  <!-- Import map to resolve bare specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.178.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.178.0/examples/jsm/",
      "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.4.1/lib/three-vrm.module.js",
      "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@2.1.0/lib/three-vrm-animation.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="ui">
    <label>VRM ファイル: <input type="file" id="vrmInput" accept=".vrm" /></label>
    <label>モーション (.vrma): <input type="file" id="animInput" accept=".vrma" /></label>
    <div id="log"></div>
  </div>
  <canvas id="c"></canvas>

  <script type="module">
    /** @ts-check */
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRMUtils, VRMLoaderPlugin } from '@pixiv/three-vrm';
    import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

    // ---------------------------------------------------------------------------
    // renderer / scene / camera
    // ---------------------------------------------------------------------------
    const canvas = /** @type {HTMLCanvasElement} */ (document.getElementById('c'));
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.4, 2.4);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.2, 0);
    controls.enableDamping = true;

    // ---------------------------------------------------------------------------
    // lights & helpers
    // ---------------------------------------------------------------------------
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(1, 3, 2);
    scene.add(dirLight);
    scene.add(new THREE.GridHelper(10, 10, 0x444444, 0x222222));

    // ---------------------------------------------------------------------------
    // state
    // ---------------------------------------------------------------------------
    /** @type {import('@pixiv/three-vrm').VRM | null} */
    let currentVRM = null;
    /** @type {THREE.AnimationMixer | null} */
    let mixer = null;

    // ---------------------------------------------------------------------------
    // utilities
    // ---------------------------------------------------------------------------
    /**
     * Ensure vrm.meta.metaVersion is defined.
     * 0.x → '0', 1.x → '1'.
     * @param {import('@pixiv/three-vrm').VRM} vrm
     */
    function ensureVRMMeta(vrm) {
      const inferredVer = (vrm.meta && 'version' in vrm.meta) ? '1' : '0';
      if (vrm.meta == null) {
        Object.defineProperty(vrm, 'meta', {
          value: { metaVersion: inferredVer },
          writable: false,
          configurable: true,
        });
      } else if (vrm.meta.metaVersion == null) {
        vrm.meta.metaVersion = inferredVer;
      } else if (vrm.meta.metaVersion === '1.0') {
        vrm.meta.metaVersion = '1';
      }
    }

    /**
     * Simple logger (UI + console)
     * @param {string} msg
     */
    function log(msg) {
      document.getElementById('log').textContent = msg;
      console.log(msg);
    }

    // ---------------------------------------------------------------------------
    // VRM loader
    // ---------------------------------------------------------------------------
    /**
     * @param {File} file
     */
    async function loadVRM(file) {
      log('Loading VRM: ' + file.name);

      const loader = new GLTFLoader();
      loader.register(parser => new VRMLoaderPlugin(parser));

      const arrayBuffer = await file.arrayBuffer();
      const gltf = await loader.parseAsync(arrayBuffer, '');
      /** @type {import('@pixiv/three-vrm').VRM} */
      const vrm = gltf.userData.vrm;
      if (!vrm) {
        throw new Error('VRM parse failed');
      }

      // dispose previous
      if (currentVRM) {
        VRMUtils.deepDispose(currentVRM.scene);
        scene.remove(currentVRM.scene);
      }

      ensureVRMMeta(vrm);

      scene.add(vrm.scene);
      currentVRM = vrm;
      log('VRM loaded: ' + file.name);
    }

    // ---------------------------------------------------------------------------
    // VRMA loader & player
    // ---------------------------------------------------------------------------
    /**
     * @param {File} file
     */
    async function loadAndPlayVRMA(file) {
      if (!currentVRM) {
        log('VRM を先に読み込んでください');
        return;
      }

      log('Loading VRMA: ' + file.name);

      const loader = new GLTFLoader();
      loader.register(parser => new VRMAnimationLoaderPlugin(parser));

      const arrayBuffer = await file.arrayBuffer();
      const gltf = await loader.parseAsync(arrayBuffer, '');
      /** @type {any} */
      const vrma = gltf.userData.vrmAnimation || gltf.userData.vrmAnimations?.[0];
      if (!vrma) {
        log('VRMA が見つかりません');
        return;
      }

      // meta fallback for old vrma
      if (!vrma.meta) vrma.meta = { metaVersion: '1' };
      if (!vrma.meta.metaVersion) vrma.meta.metaVersion = '1';

      ensureVRMMeta(currentVRM);

      const clip = createVRMAnimationClip(vrma, { vrm: currentVRM });

      if (!mixer) {
        mixer = new THREE.AnimationMixer(currentVRM.scene);
      } else {
        mixer.stopAllAction();
      }
      mixer.clipAction(clip).reset().play();
      log('Played animation: ' + (vrma.meta?.title || file.name));
    }

    // ---------------------------------------------------------------------------
    // default idle play helper
    // ---------------------------------------------------------------------------
    async function tryPlayDefaultIdle() {
      try {
        const resp = await fetch('./idle.vrma');
        if (!resp.ok) throw new Error('idle.vrma not found');
        const buffer = await resp.arrayBuffer();
        await loadAndPlayVRMA(new File([buffer], 'idle.vrma'));
      } catch (e) {
        log('idle.vrma が見つからないか読み込みに失敗しました');
      }
    }

    // ---------------------------------------------------------------------------
    // UI events
    // ---------------------------------------------------------------------------
    document.getElementById('vrmInput').addEventListener('change', e => {
      const file = /** @type {HTMLInputElement} */ (e.target).files?.[0];
      if (file) loadVRM(file).then(() => tryPlayDefaultIdle());
    });

    document.getElementById('animInput').addEventListener('change', e => {
      const file = /** @type {HTMLInputElement} */ (e.target).files?.[0];
      if (file) loadAndPlayVRMA(file);
    });

    // ---------------------------------------------------------------------------
    // render loop
    // ---------------------------------------------------------------------------
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---------------------------------------------------------------------------
    // resize
    // ---------------------------------------------------------------------------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
